/**
 * Kubernetes
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: unversioned
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/ResourceQuantity', 'model/V1AWSElasticBlockStoreVolumeSource', 'model/V1AzureDiskVolumeSource', 'model/V1AzureFileVolumeSource', 'model/V1CephFSVolumeSource', 'model/V1CinderVolumeSource', 'model/V1FCVolumeSource', 'model/V1FlexVolumeSource', 'model/V1FlockerVolumeSource', 'model/V1GCEPersistentDiskVolumeSource', 'model/V1GlusterfsVolumeSource', 'model/V1HostPathVolumeSource', 'model/V1ISCSIVolumeSource', 'model/V1NFSVolumeSource', 'model/V1ObjectReference', 'model/V1PhotonPersistentDiskVolumeSource', 'model/V1QuobyteVolumeSource', 'model/V1RBDVolumeSource', 'model/V1VsphereVirtualDiskVolumeSource'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('./ResourceQuantity'), require('./V1AWSElasticBlockStoreVolumeSource'), require('./V1AzureDiskVolumeSource'), require('./V1AzureFileVolumeSource'), require('./V1CephFSVolumeSource'), require('./V1CinderVolumeSource'), require('./V1FCVolumeSource'), require('./V1FlexVolumeSource'), require('./V1FlockerVolumeSource'), require('./V1GCEPersistentDiskVolumeSource'), require('./V1GlusterfsVolumeSource'), require('./V1HostPathVolumeSource'), require('./V1ISCSIVolumeSource'), require('./V1NFSVolumeSource'), require('./V1ObjectReference'), require('./V1PhotonPersistentDiskVolumeSource'), require('./V1QuobyteVolumeSource'), require('./V1RBDVolumeSource'), require('./V1VsphereVirtualDiskVolumeSource'));
  } else {
    // Browser globals (root is window)
    if (!root.Kubernetes) {
      root.Kubernetes = {};
    }
    root.Kubernetes.V1PersistentVolumeSpec = factory(root.Kubernetes.ApiClient, root.Kubernetes.ResourceQuantity, root.Kubernetes.V1AWSElasticBlockStoreVolumeSource, root.Kubernetes.V1AzureDiskVolumeSource, root.Kubernetes.V1AzureFileVolumeSource, root.Kubernetes.V1CephFSVolumeSource, root.Kubernetes.V1CinderVolumeSource, root.Kubernetes.V1FCVolumeSource, root.Kubernetes.V1FlexVolumeSource, root.Kubernetes.V1FlockerVolumeSource, root.Kubernetes.V1GCEPersistentDiskVolumeSource, root.Kubernetes.V1GlusterfsVolumeSource, root.Kubernetes.V1HostPathVolumeSource, root.Kubernetes.V1ISCSIVolumeSource, root.Kubernetes.V1NFSVolumeSource, root.Kubernetes.V1ObjectReference, root.Kubernetes.V1PhotonPersistentDiskVolumeSource, root.Kubernetes.V1QuobyteVolumeSource, root.Kubernetes.V1RBDVolumeSource, root.Kubernetes.V1VsphereVirtualDiskVolumeSource);
  }
}(this, function(ApiClient, ResourceQuantity, V1AWSElasticBlockStoreVolumeSource, V1AzureDiskVolumeSource, V1AzureFileVolumeSource, V1CephFSVolumeSource, V1CinderVolumeSource, V1FCVolumeSource, V1FlexVolumeSource, V1FlockerVolumeSource, V1GCEPersistentDiskVolumeSource, V1GlusterfsVolumeSource, V1HostPathVolumeSource, V1ISCSIVolumeSource, V1NFSVolumeSource, V1ObjectReference, V1PhotonPersistentDiskVolumeSource, V1QuobyteVolumeSource, V1RBDVolumeSource, V1VsphereVirtualDiskVolumeSource) {
  'use strict';




  /**
   * The V1PersistentVolumeSpec model module.
   * @module model/V1PersistentVolumeSpec
   * @version unversioned
   */

  /**
   * Constructs a new <code>V1PersistentVolumeSpec</code>.
   * PersistentVolumeSpec is the specification of a persistent volume.
   * @alias module:model/V1PersistentVolumeSpec
   * @class
   */
  var exports = function() {
    var _this = this;






















  };

  /**
   * Constructs a <code>V1PersistentVolumeSpec</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/V1PersistentVolumeSpec} obj Optional instance to populate.
   * @return {module:model/V1PersistentVolumeSpec} The populated <code>V1PersistentVolumeSpec</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();

      if (data.hasOwnProperty('accessModes')) {
        obj['accessModes'] = ApiClient.convertToType(data['accessModes'], ['String']);
      }
      if (data.hasOwnProperty('awsElasticBlockStore')) {
        obj['awsElasticBlockStore'] = V1AWSElasticBlockStoreVolumeSource.constructFromObject(data['awsElasticBlockStore']);
      }
      if (data.hasOwnProperty('azureDisk')) {
        obj['azureDisk'] = V1AzureDiskVolumeSource.constructFromObject(data['azureDisk']);
      }
      if (data.hasOwnProperty('azureFile')) {
        obj['azureFile'] = V1AzureFileVolumeSource.constructFromObject(data['azureFile']);
      }
      if (data.hasOwnProperty('capacity')) {
        obj['capacity'] = ApiClient.convertToType(data['capacity'], {'String': ResourceQuantity});
      }
      if (data.hasOwnProperty('cephfs')) {
        obj['cephfs'] = V1CephFSVolumeSource.constructFromObject(data['cephfs']);
      }
      if (data.hasOwnProperty('cinder')) {
        obj['cinder'] = V1CinderVolumeSource.constructFromObject(data['cinder']);
      }
      if (data.hasOwnProperty('claimRef')) {
        obj['claimRef'] = V1ObjectReference.constructFromObject(data['claimRef']);
      }
      if (data.hasOwnProperty('fc')) {
        obj['fc'] = V1FCVolumeSource.constructFromObject(data['fc']);
      }
      if (data.hasOwnProperty('flexVolume')) {
        obj['flexVolume'] = V1FlexVolumeSource.constructFromObject(data['flexVolume']);
      }
      if (data.hasOwnProperty('flocker')) {
        obj['flocker'] = V1FlockerVolumeSource.constructFromObject(data['flocker']);
      }
      if (data.hasOwnProperty('gcePersistentDisk')) {
        obj['gcePersistentDisk'] = V1GCEPersistentDiskVolumeSource.constructFromObject(data['gcePersistentDisk']);
      }
      if (data.hasOwnProperty('glusterfs')) {
        obj['glusterfs'] = V1GlusterfsVolumeSource.constructFromObject(data['glusterfs']);
      }
      if (data.hasOwnProperty('hostPath')) {
        obj['hostPath'] = V1HostPathVolumeSource.constructFromObject(data['hostPath']);
      }
      if (data.hasOwnProperty('iscsi')) {
        obj['iscsi'] = V1ISCSIVolumeSource.constructFromObject(data['iscsi']);
      }
      if (data.hasOwnProperty('nfs')) {
        obj['nfs'] = V1NFSVolumeSource.constructFromObject(data['nfs']);
      }
      if (data.hasOwnProperty('persistentVolumeReclaimPolicy')) {
        obj['persistentVolumeReclaimPolicy'] = ApiClient.convertToType(data['persistentVolumeReclaimPolicy'], 'String');
      }
      if (data.hasOwnProperty('photonPersistentDisk')) {
        obj['photonPersistentDisk'] = V1PhotonPersistentDiskVolumeSource.constructFromObject(data['photonPersistentDisk']);
      }
      if (data.hasOwnProperty('quobyte')) {
        obj['quobyte'] = V1QuobyteVolumeSource.constructFromObject(data['quobyte']);
      }
      if (data.hasOwnProperty('rbd')) {
        obj['rbd'] = V1RBDVolumeSource.constructFromObject(data['rbd']);
      }
      if (data.hasOwnProperty('vsphereVolume')) {
        obj['vsphereVolume'] = V1VsphereVirtualDiskVolumeSource.constructFromObject(data['vsphereVolume']);
      }
    }
    return obj;
  }

  /**
   * AccessModes contains all ways the volume can be mounted. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes
   * @member {Array.<String>} accessModes
   */
  exports.prototype['accessModes'] = undefined;
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore
   * @member {module:model/V1AWSElasticBlockStoreVolumeSource} awsElasticBlockStore
   */
  exports.prototype['awsElasticBlockStore'] = undefined;
  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * @member {module:model/V1AzureDiskVolumeSource} azureDisk
   */
  exports.prototype['azureDisk'] = undefined;
  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * @member {module:model/V1AzureFileVolumeSource} azureFile
   */
  exports.prototype['azureFile'] = undefined;
  /**
   * A description of the persistent volume's resources and capacity. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#capacity
   * @member {Object.<String, module:model/ResourceQuantity>} capacity
   */
  exports.prototype['capacity'] = undefined;
  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * @member {module:model/V1CephFSVolumeSource} cephfs
   */
  exports.prototype['cephfs'] = undefined;
  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @member {module:model/V1CinderVolumeSource} cinder
   */
  exports.prototype['cinder'] = undefined;
  /**
   * ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#binding
   * @member {module:model/V1ObjectReference} claimRef
   */
  exports.prototype['claimRef'] = undefined;
  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * @member {module:model/V1FCVolumeSource} fc
   */
  exports.prototype['fc'] = undefined;
  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
   * @member {module:model/V1FlexVolumeSource} flexVolume
   */
  exports.prototype['flexVolume'] = undefined;
  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
   * @member {module:model/V1FlockerVolumeSource} flocker
   */
  exports.prototype['flocker'] = undefined;
  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk
   * @member {module:model/V1GCEPersistentDiskVolumeSource} gcePersistentDisk
   */
  exports.prototype['gcePersistentDisk'] = undefined;
  /**
   * Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
   * @member {module:model/V1GlusterfsVolumeSource} glusterfs
   */
  exports.prototype['glusterfs'] = undefined;
  /**
   * HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: http://kubernetes.io/docs/user-guide/volumes#hostpath
   * @member {module:model/V1HostPathVolumeSource} hostPath
   */
  exports.prototype['hostPath'] = undefined;
  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * @member {module:model/V1ISCSIVolumeSource} iscsi
   */
  exports.prototype['iscsi'] = undefined;
  /**
   * NFS represents an NFS mount on the host. Provisioned by an admin. More info: http://kubernetes.io/docs/user-guide/volumes#nfs
   * @member {module:model/V1NFSVolumeSource} nfs
   */
  exports.prototype['nfs'] = undefined;
  /**
   * What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#recycling-policy
   * @member {String} persistentVolumeReclaimPolicy
   */
  exports.prototype['persistentVolumeReclaimPolicy'] = undefined;
  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   * @member {module:model/V1PhotonPersistentDiskVolumeSource} photonPersistentDisk
   */
  exports.prototype['photonPersistentDisk'] = undefined;
  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * @member {module:model/V1QuobyteVolumeSource} quobyte
   */
  exports.prototype['quobyte'] = undefined;
  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
   * @member {module:model/V1RBDVolumeSource} rbd
   */
  exports.prototype['rbd'] = undefined;
  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * @member {module:model/V1VsphereVirtualDiskVolumeSource} vsphereVolume
   */
  exports.prototype['vsphereVolume'] = undefined;



  return exports;
}));


